import {
  effect,
  EnvironmentInjector,
  inject,
  Injectable,
  runInInjectionContext,
  signal,
} from "@angular/core";
import {
  addDoc,
  collection,
  deleteDoc,
  doc,
  Firestore,
  onSnapshot,
  setDoc,
} from "@angular/fire/firestore";
import { Contact } from "../../../../core/models/contact.model";
import { AuthService } from "../../../../core/services/auth/auth.service";
import { UnsubscribeService } from "../../../../core/services/unsubscribe/unsubscribe.service";

@Injectable({
  providedIn: "root",
})
export class ContactsService {
  private authService = inject(AuthService);
  private firestore = inject(Firestore);
  private UnsubscribeService = inject(UnsubscribeService);
  private injector = inject(EnvironmentInjector);

  contacts = signal<Contact[]>([]);
  assignedToTask = signal<any[]>([]);
  showContact = signal<Contact | null>(null);
  addContact = signal<boolean>(false);
  editContact = signal<boolean>(false);
  contactCreatedOrUpdated = signal<string>("");

  /**
   * Constructs a new instance of the ContactsService.
   *
   * When the AuthService's user ID changes, this constructor will automatically
   * load the user's contact list from Firestore.
   */
  constructor() {
    effect(() => {
      const userId = this.authService.userId();
      if (userId) {
        this.loadContacts(userId);
      }
    });
  }

  /**
   * Loads the user's contact list from Firestore and updates the component's
   * `contacts` signal.
   *
   * @param userId - The ID of the user whose contact list to load.
   */
  private loadContacts(userId: string): void {
    const contactsCollection = collection(
      this.firestore,
      `users/${userId}/contacts`,
    );

    runInInjectionContext(this.injector, async () => {
      const unsubscribe = onSnapshot(contactsCollection, (snapshot) => {
        const contactsData = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...(doc.data() as Contact),
        }));

        this.contacts.set(
          contactsData.sort((a, b) =>
            a.displayName.localeCompare(b.displayName),
          ),
        );
      });

      this.UnsubscribeService.add(unsubscribe);
    });
  }

  /**
   * Creates a new contact in the user's contact list.
   *
   * @param contact - The contact object containing information to be added.
   *                  The object may include fields such as displayName, email, and phone.
   *                  The contact's `id` field is ignored as it is automatically generated by Firestore.
   * @returns A Promise that resolves when the contact creation is complete.
   */
  async createContact(contact: any): Promise<void> {
    const userId = this.authService.userId();
    if (!userId) return;

    const contactsCollection = collection(
      this.firestore,
      `users/${userId}/contacts`,
    );

    const { id, ...contactData } = contact;

    await addDoc(contactsCollection, contactData);
  }

  /**
   * Updates an existing contact in the user's contact list.
   *
   * @param contact - The contact object containing updated information.
   *                  Must include the contact's `id` and other data fields to update.
   * @returns A Promise that resolves when the contact update is complete.
   */
  async updateContact(contact: any): Promise<void> {
    const userId = this.authService.userId();
    if (!userId) return;

    const contactsCollection = collection(
      this.firestore,
      `users/${userId}/contacts`,
    );

    const { id, ...contactData } = contact;

    await setDoc(doc(contactsCollection, id), contactData);
  }

  /**
   * Deletes a contact from the user's contact list.
   *
   * @param contactId - The ID of the contact to be deleted.
   */
  async deleteContact(contactId: string): Promise<void> {
    const userId = this.authService.userId();
    if (!userId) return;

    const contactsCollection = collection(
      this.firestore,
      `users/${userId}/contacts`,
    );

    await deleteDoc(doc(contactsCollection, contactId));
  }

  /**
   * Adds a contact to the assigned task list if it doesn't already exist.
   *
   * @param contact - The contact to be added, identified by its displayName.
   * This updates the assignedToTask list by appending the specified contact if it's not already present.
   */
  addContactToTask(contact: any): void {
    const current = this.assignedToTask();
    const exists = current.some((c) => c.displayName === contact.displayName);

    if (!exists) {
      this.assignedToTask.set([...current, contact]);
    }
  }

  /**
   * Removes a contact from the assigned task list.
   *
   * @param contact - The contact to be removed, identified by its displayName.
   * This updates the assignedToTask list by filtering out the specified contact.
   */
  removeContactFromTask(contact: any): void {
    const updated = this.assignedToTask().filter(
      (c) => c.displayName !== contact.displayName,
    );
    this.assignedToTask.set(updated);
  }

  /**
   * Generates a color in HSL format based on the input name.
   *
   * @param name - The name used to generate a unique color.
   * @returns A string representing the color in HSL format, with a calculated
   * hue derived from the hash of the name, and fixed saturation and lightness
   * values for vibrant and consistent appearance.
   */
  generateContactColor(name: string): string {
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    const hue = Math.abs(hash % 360);
    const saturation = 100; // More vibrant colors
    const lightness = 50; // Brighter colors

    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
  }

  /**
   * Extracts and returns the initials from a given name.
   *
   * @param name - The full name from which to extract initials.
   * @returns A string containing the initials. If the name is a single word,
   * returns the first letter in uppercase. If the name consists of multiple words,
   * returns the first letter of the first two words in uppercase. Returns an empty
   * string if the input name is empty or not provided.
   */
  getInitials(name: string): string {
    if (!name) return "";

    const names = name.trim().split(" ");

    if (names.length === 1) {
      return names[0][0].toUpperCase();
    }
    return names[0][0].toUpperCase() + names[1][0].toUpperCase();
  }
}
